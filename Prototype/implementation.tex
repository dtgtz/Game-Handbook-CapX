\section{Prototype Implementation}
%Steffen\\\\
CapitalismX is a Node.js\footnote{https://nodejs.org/} app written in JavaScript and the stylesheet language SASS\footnote{https://sass-lang.com}. It makes use of the library React\footnote{https://reactjs.org/} and its XML-like JavaScript syntax extension JSX to define user interface components. Furthermore, Redux\footnote{https://redux.js.org/} is used to manage the state of components and their communication with each other. 3D graphics are realized using Three.js\footnote{https://threejs.org/}. NPM\footnote{https://www.npmjs.com/} helps to manage dependencies and deployment.
\\
Various smaller NPM packages are used for a number of tasks. A full list of dependencies can be found in the \texttt{package.json} file in the root directory of the prototype project folder.\\\\
It should be possible to run the app in any state-of-the-art browser, but at the moment it is only tested in Google Chrome\footnote{https://google.com/chrome/} (version 72.0.3626.109).
\\
This section doesn't cover the prototype implementation in its entirety, but will highlight some of the key implementation decisions, especially those concerned with the game mechanics.

\subsection{Simulation Graph}

One of the key challenges in the prototype implementation was the technical specification of all the complex relationships between variables and objects in the game mechanics graph. The complexity of this graph is mostly due to the heterogeneity of the data types, ranging from elementary integers to arrays of complex nested objects. 
 Hence, a conventional graph of real number vertices and real edge weights is not sufficient for our needs.
 
 
The goal was to implement a general-purpose graph abstraction which can deal with elementary data types as well as objects and arrays.
Therefore, each node consists of a dictionary of vertices each storing their key, value, an arbitrary weight function with an arbitrary number of parameters, and the keys of all incoming nodes (mapping to the parameters in the weight function). With this data structure, a separate adjacency list is superfluous, as each vertex already stores its incoming vertices and weight functions, and thus all edges in the graph are defined.


Moreover, we extend this graph class by introducing a counter for the elapsed game time. Periodically, the graph time is forwarded by one time quantum (in our game one day), which triggers a complete recalculation of the graph. This counter is essential for weight functions involving time, e.g. to model the degrading demand of a product over time.
\\


This approach allows for a high level of encapsulation when defining the graph in the code. There are two separate types of vertices. First, we have root vertices in the beginning of the graph. They directly correspond to the input values the user specifies in the GUI. Most importantly, they have no incoming edges. The following function of the \texttt{SimulationGraph} class can be used to create a root vertex:

\begin{center}
	\texttt{createVertex(key, defaultValue)}
\end{center}

Second, we have internal vertices with at least one incoming vertex. As they do have incoming edges we also have to pass a weight function \texttt{wf} and the weight function parameter vertex keys:
\begin{center}
	\texttt{createCalculatedVertex(key, defaultValue, wf, keys)}
\end{center}
 
 In addition, we also might want to use the simulation time and previous value of the node in the function. Thus, the weight function is also implicitly given the current time and optionally the previous vertex value as a parameter.
 %\newpage
 
 In the end, an example implementation of a normally distributed investment return simulation could be constructed like the following:\\
 
 \begin{algorithmic}[1]
 	\STATE \texttt{createVertex("investmentAmount", 100)}
    \STATE \texttt{createVertex("investmentMean", 1.08)}
    \STATE \texttt{createVertex("investmentStd", 0.2)}
	\STATE \texttt{createCalculatedVertex(\newline \hspace*{1mm} "investmentEarnings",\newline \hspace*{2mm} function(t, amount, risk, std) \{ \newline \hspace*{10mm}return amount * gauss(mean, std)  \newline \hspace*{2mm} \},\newline \hspace*{2mm} ["investmentAmount", "investmentRisk", "investmentMean"]\newline )}    
  \end{algorithmic}
  \vspace{1cm}
  The entire game mechanics are modeled in this way. The complete graph implementation for our game can be found in the \texttt{SimulationGraph} class in the directory \texttt{src/model/graph/} of the game directory. Only the root vertices can be changed from outside the \texttt{SimulationGraph} class and their values are fetched from the GUI state each simulation cycle. A change in these vertices corresponds to a new user input.